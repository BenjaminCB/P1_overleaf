\section{Reflection}
Our initial goal with this program was to optimize the work scheduling process at \siemens, time wise. Since the previous method took approximately four hours and our solution takes approximately ten minutes, there can be no doubt we have reached that goal. According to the requirements-section, this program fulfills all but one of the mentioned requirements.

This ties in to the one noteworthy fallacy of the program, however small and insignificant to the overall functionality of the program, it may be, the GUI. Our program is not particularly user friendly to a fist time user as we found out in our test with our contact from \siemens. The lack of user friendliness was the reason it took around ten minutes despite us making a step by step instruction manual.

One other thing we have discussed improving regarding the program is the time complexity. In some of the functions, particularly the weighting function, we could potentially have improved the time complexity. This was by no means a priority, since our program was already quite well functioning and fast, with an execution time of 0.02 seconds. Overall our program has been a success in meeting the initial requirements, however there are still some areas in which we could have improved the program. Luckily these areas were of low priority and therefore not a hindrance to the overall functionality of the program.

\section{Sub-conclusion to chapter two}
There are several factors that we have taken into consideration for the development of the solution, since the problem analysis states a multitude of requirements. Firstly, the requirements have been listed after priority to make it easier for us, as well as the reader, to understand which parts of the program are more important. This has proven to be quite useful since we always knew what should be prioritized when creating the program.

The "Specification and design" section has also been of great use to us, since it in detail provided necessary guidelines and information regarding how the program should work. The third section was useful for keeping track of the overall structure of our program. That has been quite important, since we easily could have messed up the management of creating our program. This could have led to improper coordination of the creation process and therefore a worse product.

Obviously, it was also necessary to test the program. This was done by creating a couple of test cases in the form of a proposed schedule, one of which was an extreme, worst case scenario. Not all the cases were successful at first try, but after some adjusting, the program worked as intended. What we have learned from those test, is that it is of great importance to test the program after finishing development to make sure that it works as intended, as well as testing small functions during development, since it will make debugging much easier.

The second chapter has made it much easier for us the create the solution since it has provided both overall as well as more detailed guidelines, as well as helped us lay out a plan of how we should create the program.